"""Generate `in.equil.lammps` and `mbx.json` for an MB-pol slab equilibration.

Usage: python gen_input.py --data-file FILE --nwaters N --lx LX --lz LZ --outdir DIR
"""

import argparse
import json
import os


# ── LAMMPS input template ─────────────────────────────────────────────────────

LAMMPS_TEMPLATE = """\
# ─────────────────────────────────────────────────────────────────────────────
# MB-pol NVT equilibration
# {nwaters} H2O  |  {lx:.4f} × {lx:.4f} × {lz:.4f} Å
# Generated by mbx-water-slab-prep / gen_input.py
#
# IMPORTANT — this is an unequilibrated Packmol structure.
# Run for at least 1–2 ns before collecting any production data.
# Adjust EQUIL_STEPS below to extend the run if needed.
#
# Requires mbx.json in the same directory (also generated by this tool).
# ─────────────────────────────────────────────────────────────────────────────

units           real
atom_style      full
boundary        p p p
processors      * * * map xyz

read_data       {data_file}

pair_style      mbx {cutoff}
pair_coeff      * * 1 h2o 1 2 2 json mbx.json

# MBX handles all intra- and inter-molecular interactions.
# Bond/angle sections are present for special-bond exclusions only.
bond_style      none
angle_style     none

neighbor        2.0 bin
neigh_modify    every 1 delay 0 check yes

timestep        {timestep}        # fs

# ── Step 1: Energy minimisation ───────────────────────────────────────────────
# Relaxes residual close contacts from Packmol so that the MBX induced-dipole
# CG solver converges on the very first dynamics step.  The stopping criterion
# is loose — we only need the geometry to be free of catastrophic overlaps.

minimize        1.0e-4 1.0e-6 500 5000
reset_timestep  0

# ── Step 2: NVT equilibration ─────────────────────────────────────────────────
variable        T      equal  {temp}
variable        Tdamp  equal  {tdamp:.1f}   # ~100 × timestep (standard for MB-pol)
variable        EQUIL_STEPS equal {equil_steps}

thermo_style    custom step temp pe ke etotal press density cpu cpuremain
thermo          {thermo_freq}

dump            traj all custom {dump_freq} traj_equil.lammpstrj &
                id mol type x y z xu yu zu vx vy vz
dump_modify     traj sort id flush yes

# Rolling restart pair — allows resuming from the most recent checkpoint
restart         {restart_freq} restart_equil.a restart_equil.b

fix             1 all nvt temp ${{T}} ${{T}} ${{Tdamp}}

run             ${{EQUIL_STEPS}}

# ── Finalise ──────────────────────────────────────────────────────────────────
unfix           1
undump          traj
write_data      equil_final.data
"""


# ── MBX JSON ──────────────────────────────────────────────────────────────────

def make_mbx_json(cutoff: float) -> dict:
    return {
        "Note": [
            "MBX configuration for MB-pol slab simulations. See mbx.json keys for parameters."
        ],
        "MBX": {
            "box": [],
            "realspace_cutoff": cutoff,
            "twobody_cutoff": 9.0,
            "threebody_cutoff": 7.0,
            "dipole_tolerance": 1e-8,
            "dipole_max_it": 100,
            "dipole_method": "cg",
            "alpha_ewald_elec": 0.60,
            "grid_density_elec": 2.5,
            "spline_order_elec": 6,
            "alpha_ewald_disp": 0.60,
            "grid_density_disp": 2.5,
            "spline_order_disp": 6,
            "ignore_2b_poly": [],
            "ignore_3b_poly": []
        }
    }


# ── main ──────────────────────────────────────────────────────────────────────

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--data-file",    required=True,  help="Path to the LAMMPS data file")
    p.add_argument("--nwaters",      type=int,   required=True)
    p.add_argument("--lx",           type=float, required=True)
    p.add_argument("--lz",           type=float, required=True)
    p.add_argument("--temp",         type=float, default=298.15,   help="NVT temperature (K)")
    p.add_argument("--equil-steps",  type=int,   default=2_500_000,
                   help="NVT run length in steps (default 2 500 000 = 0.5 ns at 0.2 fs)")
    p.add_argument("--cutoff",       type=float, default=9.0,  help="MBX real-space cutoff (Å)")
    p.add_argument("--timestep",     type=float, default=0.2,  help="MD timestep (fs)")
    p.add_argument("--outdir",       required=True)
    args = p.parse_args()

    os.makedirs(args.outdir, exist_ok=True)

    timestep     = args.timestep
    tdamp        = 100 * timestep           # ~100× timestep
    thermo_freq  = max(100, int(200.0  / timestep))   #  ≈ every 0.04 ps
    dump_freq    = max(100, int(1000.0 / timestep))   #  ≈ every 0.2 ps
    restart_freq = max(100, int(10000.0 / timestep))  #  ≈ every 2 ps

    # Use only the filename (not a full path) in the read_data line so the
    # input file is portable when copied to a run directory.
    data_basename = os.path.basename(args.data_file)

    lammps_text = LAMMPS_TEMPLATE.format(
        nwaters      = args.nwaters,
        lx           = args.lx,
        lz           = args.lz,
        data_file    = data_basename,
        cutoff       = args.cutoff,
        timestep     = timestep,
        temp         = args.temp,
        tdamp        = tdamp,
        equil_steps  = args.equil_steps,
        thermo_freq  = thermo_freq,
        dump_freq    = dump_freq,
        restart_freq = restart_freq,
    )

    lammps_out = os.path.join(args.outdir, "in.equil.lammps")
    with open(lammps_out, "w") as f:
        f.write(lammps_text)
    print(f"  LAMMPS input  → {lammps_out}")

    mbx_out = os.path.join(args.outdir, "mbx.json")
    with open(mbx_out, "w") as f:
        json.dump(make_mbx_json(args.cutoff), f, indent=4)
    print(f"  MBX config    → {mbx_out}")

    dt_ns = args.equil_steps * timestep * 1e-6
    print(f"  Equilibration : {args.equil_steps:,} steps  "
          f"({dt_ns:.3f} ns at {timestep} fs/step)  T = {args.temp} K")


if __name__ == "__main__":
    main()
